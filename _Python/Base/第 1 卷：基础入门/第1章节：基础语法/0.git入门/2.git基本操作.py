# 基本操作
"""
    在工作树中，我们日常所进行的工作无非是对 Git仓库所管理的文档进行修改，或者添加／删除一些文件。
这些操作与采用 Git 管理我们的文档之前没有任何差异，只是在你认为一个工作阶段完成之时，要记得通知 Git，
命令它记下你所进行更新，
    这一步骤是通过生成文档快照并将其加入到索引中来实现的。
"""

# --------------------------------------------------------------------------------------
# 版本更新

# * 记录更新（ git add）
"""    
    譬如，向项目的工作树 目录（下文将用bash变量$WORK表示）添加了一份新文档 hello.tex.
    (Latex是一种文件生成系统，它生成纯文本文件，后缀名为.tex)
我需要通知 Git 记住我的这一更新：
"""
#   $ cd $WORK
#   $ git add hello.tex
# 这样，Git 就会将有关文件的更新添加到索引中。

# ---------------------------------------------------
# 接着，又修改了文件，继续使用 git-add 命令将它们的更新添加到索引中：
#   $ git add 1.tex 2.tex


# ---------------------------------------------------
# 将所做的全部更新添加到索引中，比较轻省的做法就是：
#   $  git add  .
"""
    git add  .命令除了能够判断出当前目录（包括其子目录） 所有被修改或者已删除的文档，
还能判断 用户所添加的新文档，并将其信息追加到索引中。
"""

# ---------------------------------------------------
# 剔除文件
'''
    可以通过 git  reset   HEAD   <path>. ..将 path对应的文件从索引库中剔除，但是 path对应的文件内容本身不受此影响。
'''
# 比如：
#   $ git add 1.txt
#   $ git reset HEAD 1.txt
#   Unstaged changes after reset:
#   M       1.txt
"""
注：
Unstaged changes after reset ：    
    意思是回退后，有为被追踪的文件。 
M 1.txt ： 
    表示 readme.txt 文件修改后，未被追踪，也就是修改后未添加到暂存区的状态。

可以通过 git add -i命令中的 revert 子命令, 把已经添加到索引库中的文件从索引库中剔除。
可以通过 git add -i命令中的 update 子命令, 把已经被 git管理的修改文件添加到索引库中。
可以通过 git add -i命令中的 add untracked 子命令, 把还没被 git管理(untracted)的文件添加到索引库中。
"""

# ---------------------------------------------------
# * 提交更新（ git commit）

# 执行 git commit命令，将索引内容添加到仓库中。
#       git commit   -m  "提交的描述信息"
''' 注： 如果不用 -m参数的话，git将调到一个文本编译器（通常是vim）来让你输入提交的描述信息。'''

# 将所做的全部更新添加到索引中，比较轻省的做法就是：
#       git commit  -a  -m  "提交的描述信息"
"""
注：
    git commit  命令的 -a  选项可只将所有被修改或者已删除的 且已经被git管理 的文档提交到仓库中。 
如果只是修改或者删除了已被 Git 管理的文档，是没必要使用 git add 命令的。
    git add  .命令除了能够判断出当前目录（包括其子目录） 所有被修改或者已删除的文档，还能判断用户所添加
的新文档，并将其信息追加到索引中。
    另外 ，要注意的问题是，Git 不会主动记录你对文档进行的更新，除非你对它发号施令（比如通过git add命令 ）。
"""

# --------------------------------------------------------------------------------------
# 查看文件的状态（ git status）
'''
    git status 命令可以列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件.
注意，可以通过 git add -i 命令查看 <path> 中被所有修改过或已删除文件但没有提交的文件，它有类似 git status 的功能.
'''

# --------------------------------------------------------------------------------------
# 移除文件( git rm)
'''
    在git中我们可以通过 git rm命令把一个文件删除，并把它从git的仓库管理系统中移除。
但是注意最后要执行 git commit才真正提交到git仓库.
'''

# 例如：
#   删除1.txt文件，并把它从git的仓库管理系统中移除。
# git rm 1.txt

# 例如：
#   删除文件夹Folder，并把它从git的仓库管理系统中移除。
# git rm -r Folder

# 例如：
# 在通过 git add   2.txt 命令把文件 2.txt添加到索引库中后，
# 又通过 git rm --cached  2.txt 把文件 10.txt从git的索引库中移除，
# 但是对文件 10.txt本身并不进行任何操作。
#   $  git add 2.txt
#   $ git rm --cached  2.txt
#   rm '2.txt'
#   $ Is
#   2.txt  2  3.txt  5.txt  readme.txt

# --------------------------------------------------------------------------------------
# 推送本地更新到服务器（ git push）
#   可以通过 git push把本地仓库的更新推到服务器仓库。

# --------------------------------------------------------------------------------------
# 拉服务器更新拉到本地（ git pull）
#   可以通过 git pull命令把服务器仓库的更新拉到本地仓库中。

# --------------------------------------------------------------------------------------
# 查看版本历史

# * 查看当前项目的日志 (git log)
'''
    在工作树中，使用 git log 命令可以查看当前项目的日志，也就是你在使用 git commit向仓库提交新版本时所属如的版本更新信息。
    每一个版本都对应着一次项目版本更新提交。在项目日志信息中，每条日志的首行为版本更新提交所进行的命名，我们可以将该命名理解为 项目版本号。
    项目版本号应该是唯一的，默认由Git 自动生成，用以标示项目的某一次更新。
'''
# 观察每一次版本的大致变动情况，命令：
# $ git log --stat --summary

'''
如果我们将项目版本号用作git show 命令的参数，即可查看该次项目版本的更新细节：
    $  git show   [version_numbers]
除了使用完整的版本号查看项目版本更新细节之外，也还可以使用以下方式：
    $  git show  214cf  # 一般只使用版本号的前几个字符即可
    $  git show  HEAD  # 显示当前分支的最新版本的更新细节
    $ git show  # 显示当前分支的最新版本的更新细节，它相当于 git show  HEAD
    
每一个项目版本号通常都对应存在一个父版本号，也就是项目的前一次版本状态。

可使用如下命令查看当前项目版本的父版本更新细节：
$  git show  HEAD ^  # 查看HEAD 的父版本更新细节
$  git show  HEAD ^^   # 查看HEAD 的祖父版本更新细节
$  git show  HEAD ~4  # 查看HEAD 的祖父之祖父的版本更新细节
'''

# --------------------------------------------------------------------------------------
# 标签（ git tag）
#   你可以对项目版本号进行自定义，然后就可以使用自定义的版本号查看对应的项目版本更新细节：
#       $  git tag  v0.1 dfb02
#       $  git show
# 实际上，上述命令并非是真正的进行版本号自定义，只是制造了一个 tag 对象而已，这在进行项目版本对外发布时比较有用。

# --------------------------------------------------------------------------------------
# 撤销
#   可以使用 git reset或 git checkout或 git revert来撤销我们的修改。

# --------------------------------------------
# 撤销未提交的修改 ( git reset)

'''
如果工作目录(work tree)里搞的一团乱麻, 但是还没有把它们提交, 可以通过下面的命令, 让工作目录
回到上次提交时的状态(last committed state):
  $ git reset --hard  HEAD
注： 该命令会把所有工作目录中所有未提交的内容清空(不包括未置于版控制下的文件 untracked files). 
从另一种角度来说, 这会让"git diff" 和"git diff --cached"命令的显示法都变为空.
'''

# 只恢复一个文件,如"hello.rb", 使用 git checkout
# $  git checkout --  hello.rb
# 这条命令把 hello.rb 从HEAD中签出并且把它恢复成未修改时的样子.

# 想要恢复当前目录所有修改的文件,可以使用
# $ git checkout  .
# 这条命令把 当前目录所有修改的文件  从 HEAD 中迁出并且把它恢复成未修改时的样子.

# --------------------------------------------
# 撤销已提交的修改

'''
两种截然不同的方法去处理这个问题:
1 .创建一个新的提交(commit), 在新的提交里撤消老的提交所作的修改. 
这种作法在你已经把代码发布(git push)到服务器的情况下十分正确.
2 .去修改你的老提交(old commit). 但是如果已经把代码发布(git push)到了服务器,那么千万别这么做;
git不会处理项目的历史会改变的情况,如果一个分支的历史被改变了那以后就不能正常的合并.
'''

# 1.创建新提交来撤销(revert)前期提交(commit)的修改
#   把想撤销修改的某个提交( commit )的名字(reference)做为参数传给命令:  git revert 就可以了.
# $  git revert   HEAD
# 可以修改新提交(new commit)里的提交注释信息.

# 撤消“上上次”(next-to-last)的提交:
# $   git revert  HEAD^


# 撤销某个commit的提交
# $ git revert   [version_numbers]
'''
    在执行 git revert 时,git尝试去撤消老提交的修改,如果你最近的修改和要撤消的修改有重叠(overlap),
那么就会被求手工解决冲突(conflicts),　就像解决合并(merge)时出现的冲突一样.
    另外，git revert 其实不会直接创建一个提交(commit), 把撤消后的文件内容放到索引(index)里,
你需要再执行 git commit 命令，它们才会成为真正的提交(commit).
'''

# 撤销旧提交但不保留修改（提交的修改和文件系统中的修改）
#   可以使用 git reset  --hard 来达到该目的。


# 撤销旧提交但保留修改（文件系统中保留修改）
#   做修改或不做修改再次提交的话，可以使用 git reset  --mixed 或 git reset   --soft 来达到该目的。


# 追加提交来修改提交
'''  
    git commit 现在支持一个叫 --amend 的参数，能修改刚才的这个提交(HEAD commit). 
这项机制能让你在代码发布前,添加一些新的文件或是修改你的提交注释(commit message).
    另外,若是在老提交(older commit)里发现一个错误, 但是还未发布(git push)到代码服务器上. 可以使用 git rebase 命
令的交互模式, " git rebase -i "会提示你在编辑中做相关的修改. 这样其实就是让你在rebase的过程来修改提交.

'''

# --------------------------------------------------------------------------------------
# 版本的回退
#   可以使用 git checkout 来实现版本的回退，即回退到某个 commit 或 tag.

# 示例1：
# 回退到到 branch_a的版本[version_numbers]
# $ git checkout   branch_a
# $ git checkout   [version_numbers]

# 示例2：
#  回退到 tag_a代表的 tag点
# $ git checkout   tag_a

# 回到最新的版本，执行    $ git   checkout   branch_a:

# --------------------------------------------------------------------------------------
# * 分支管理
'''  项目分支 master分支（主分支），该分支是由 Git 自动产生的。
在此之前，我们针对项目版本的各种操作都是在主分支上进行的，只是我们未察觉它的存在而已。'''

# * 创建分支
#   Git 可以轻松地产生新的项目分支：
#       $  git branch  local
# 对于新产生的 local 分支，初始时是完全等同于主分支的。
# 但是，在 local 分支所进行的所有版本更新工作都不影响主分支，这意味着作为项目的参与者，可以在 local 中开始各种各样的更新尝试。

# ---------------------------------------------------
# * 查看分支
#   查看项目仓库中存在多少分支，可直接使用 git-branch 命令，
#   查看项目分支列表：
#       $  git branch
#       local
#       *  master
# 在上述操作输出结果中，若分支名之前存在 *  符号，表示此分支为当前分支。
# 其实 Git 各分支不存在尊卑之别，只存在哪个分支是当前分支的区别。
# 为了某种良好的秩序，默认是将 master分支视为主分支。

# ---------------------------------------------------
# * 分支的切换
#   使用 git-branch 命令产生了 local 分支，但是 Git不会自动将当前分支切换到 local下。
#   可使用 git-checkout 命令实现分支切换：
#       $ git checkout local

# ---------------------------------------------------
# * 分支的合并
'''
    我们产生了 local分支，并在该分支下进行了诸多修改与数次的版本更新提交，但是该如何将这一分支的最终状态提交到 master 分支中呢？
'''
# git-merge 命令可实现两个分支的合并：
# $  git checkout   master    # 将当前分支切换为master
# $  git merge   local      # 将 local分支与当前分支合并

# 当一个分支检查无误并且与 master 分支成功合并完毕后，那么这一分支基本上就没有存在的必要性了，可以删除掉：
# $  git branch  -d   local
# 注意： git-branch 的 -d 选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。
#       如果想不问青红皂白地删除一个分支，可以使用 git-branch 的 -D 选项。
#   另外，我们还可以通过 git rebase 来实现分支的合并。

# --------------------------------------------------------------------------------------
# 储藏修改（ git stash）
"""
    当你正在做一项复杂的工作时,发现了一个和当前工作不相关但是又很讨厌的 bug. 你这时想先修复 bug再做手头的工作,
那么就可以用 git stash来保存当前的工作状态, 等你修复完 bug后,执行 git stash apply 就可以回到之前的工作里.
"""

# --------------------------------------------------------------------------------------
# 工作流

# * 基本工作流
# 集中式工作流
# 功能分支工作流

# * 高级工作流
# gitflow 工作流
# forking 工作流
# --------------------------------------------------------------------------------------
