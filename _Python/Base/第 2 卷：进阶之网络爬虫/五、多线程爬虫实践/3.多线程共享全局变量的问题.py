#!/usr/bin/env python3
# coding=utf-8

"""
# @Create   : 2022/6/30  15:58
# @Author   : 30945  HuaYin
# @Description  :   说明文件功能
@Date Time              @Software              @Version
-----------------      ----------------        -------------
2022/6/30   15:58       Software Name          1.0.0
"""

#  -----------------------------------------------------------------------------
import threading

# 多线程共享全局变量的问题
"""
    多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成
了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。
    因为多线程运行的不确定性,最后的结果可能是随机的。
"""

# 线程 1 ：value +1   -->  | value
# 线程 2 ：value +1   -->  | value



value = 0

# 锁机制___Lock类
gLock = threading.Lock()


# 自定义函数 add_value
def add_value():
    # 声明变量:如果在函数中修改了全局变量，需要 global 关键字声明
    global value
    # 思考：视频当设定为1000000时，结果错误? 但是，我的输出结果是正确的。
    """
    处理方法：锁机制和threading.Lock类
        为了解决共享全局变量的问题。threading提供了一个Lock类，这个类可以在某个线程
    访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其
    他线程才能进来处理。
    使用锁的原则：
    1. 把尽量少的和不耗时的代码放到锁中执行。
    2. 代码执行完成后要记得释放。
    """
    # 锁 Lock
    gLock.acquire()  # acquire 获得，获取，收购
    for i in range(1000000):
        # for i in range(100):
        value += 1
    # 释放 release
    gLock.release()

    print("value的值：%d" % value)


def main():
    for j in range(5):
        th = threading.Thread(target=add_value)
        th = threading.Thread(add_value())
        th.start()


if __name__ == '__main__':
    main()

#  -----------------------------------------------------------------------------
"""
python中的各种锁：

一、全局解释器锁（GIL）
1、什么是全局解释器锁
    每个CPU在同一时间只能执行一个线程，那么其他的线程就必须等待该线程的全局解释器，使用权消失
后才能使用全局解释器，即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机
制称为全局解释器锁（GIL）。
    GIL的设计简化了CPython的实现，使的对象模型包括关键的内建类型，如：字典等，都是隐含的，可以
并发访问的，锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。

2、全局解释器锁的好处
    1、避免了大量的加锁解锁的好处
    2、使数据更加安全，解决多线程间的数据完整性和状态同步
    3、全局解释器的缺点
        多核处理器退化成单核处理器，只能并发不能并行。
    4、GIL的作用：              
        多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（cpu）。
二、同步锁
    1、什么是同步锁？
        同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，
    那么就要用到同步锁。

　　2、为什么用同步锁？
        因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，
    这样就有可能会影响到该程序结果的完整性。

　　3、怎么使用同步锁？
        只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。
    4、同步锁的所用：
        为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。

三、死锁
    1、什么是死锁？
        指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源或者程序推进顺序不当而相互等待的一个现象。
　　2、死锁产生的必要条件？
        互斥条件
        请求和保持条件
        不剥夺条件
        环路等待条件
    3、处理死锁的基本方法？
        预防死锁
        避免死锁（银行家算法）
        检测死锁（资源分配）
        解除死锁：剥夺资源、撤销进程

四、什么是递归锁？
    在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。
    这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次
require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。
    递归锁分为可递归锁与非递归锁。

"""
